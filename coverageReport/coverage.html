
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>generated: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/hello/hello/generated/hello.pb.go (0.0%)</option>
				
				<option value="file1">github.com/hello/hello/generated/hello_grpc.pb.go (0.0%)</option>
				
				<option value="file2">github.com/hello/hello/mock/mock_pb.go (0.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
//         protoc-gen-go v1.35.2
//         protoc        v5.28.3
// source: hello.proto

package hello

import (
        protoreflect "google.golang.org/protobuf/reflect/protoreflect"
        protoimpl "google.golang.org/protobuf/runtime/protoimpl"
        reflect "reflect"
        sync "sync"
)

const (
        // Verify that this generated code is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
        // Verify that runtime/protoimpl is sufficiently up-to-date.
        _ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

// Request message
type HelloRequest struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (x *HelloRequest) Reset() <span class="cov0" title="0">{
        *x = HelloRequest{}
        mi := &amp;file_hello_proto_msgTypes[0]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HelloRequest) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HelloRequest) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HelloRequest) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_hello_proto_msgTypes[0]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HelloRequest.ProtoReflect.Descriptor instead.
func (*HelloRequest) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_hello_proto_rawDescGZIP(), []int{0}
}</span>

func (x *HelloRequest) GetName() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Name
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Response message
type HelloReply struct {
        state         protoimpl.MessageState
        sizeCache     protoimpl.SizeCache
        unknownFields protoimpl.UnknownFields

        Message        string `protobuf:"bytes,1,opt,name=message,proto3" json:"message,omitempty"`
        Acknowledgment string `protobuf:"bytes,2,opt,name=acknowledgment,proto3" json:"acknowledgment,omitempty"`
}

func (x *HelloReply) Reset() <span class="cov0" title="0">{
        *x = HelloReply{}
        mi := &amp;file_hello_proto_msgTypes[1]
        ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
        ms.StoreMessageInfo(mi)
}</span>

func (x *HelloReply) String() string <span class="cov0" title="0">{
        return protoimpl.X.MessageStringOf(x)
}</span>

func (*HelloReply) ProtoMessage() {<span class="cov0" title="0">}</span>

func (x *HelloReply) ProtoReflect() protoreflect.Message <span class="cov0" title="0">{
        mi := &amp;file_hello_proto_msgTypes[1]
        if x != nil </span><span class="cov0" title="0">{
                ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
                if ms.LoadMessageInfo() == nil </span><span class="cov0" title="0">{
                        ms.StoreMessageInfo(mi)
                }</span>
                <span class="cov0" title="0">return ms</span>
        }
        <span class="cov0" title="0">return mi.MessageOf(x)</span>
}

// Deprecated: Use HelloReply.ProtoReflect.Descriptor instead.
func (*HelloReply) Descriptor() ([]byte, []int) <span class="cov0" title="0">{
        return file_hello_proto_rawDescGZIP(), []int{1}
}</span>

func (x *HelloReply) GetMessage() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Message
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (x *HelloReply) GetAcknowledgment() string <span class="cov0" title="0">{
        if x != nil </span><span class="cov0" title="0">{
                return x.Acknowledgment
        }</span>
        <span class="cov0" title="0">return ""</span>
}

var File_hello_proto protoreflect.FileDescriptor

var file_hello_proto_rawDesc = []byte{
        0x0a, 0x0b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x12, 0x05, 0x68,
        0x65, 0x6c, 0x6c, 0x6f, 0x22, 0x22, 0x0a, 0x0c, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x12, 0x12, 0x0a, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x18, 0x01, 0x20, 0x01,
        0x28, 0x09, 0x52, 0x04, 0x6e, 0x61, 0x6d, 0x65, 0x22, 0x4e, 0x0a, 0x0a, 0x48, 0x65, 0x6c, 0x6c,
        0x6f, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x12, 0x18, 0x0a, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67,
        0x65, 0x18, 0x01, 0x20, 0x01, 0x28, 0x09, 0x52, 0x07, 0x6d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65,
        0x12, 0x26, 0x0a, 0x0e, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77, 0x6c, 0x65, 0x64, 0x67, 0x6d, 0x65,
        0x6e, 0x74, 0x18, 0x02, 0x20, 0x01, 0x28, 0x09, 0x52, 0x0e, 0x61, 0x63, 0x6b, 0x6e, 0x6f, 0x77,
        0x6c, 0x65, 0x64, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x32, 0x3d, 0x0a, 0x07, 0x47, 0x72, 0x65, 0x65,
        0x74, 0x65, 0x72, 0x12, 0x32, 0x0a, 0x08, 0x53, 0x61, 0x79, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x12,
        0x13, 0x2e, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x48, 0x65, 0x6c, 0x6c, 0x6f, 0x52, 0x65, 0x71,
        0x75, 0x65, 0x73, 0x74, 0x1a, 0x11, 0x2e, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x2e, 0x48, 0x65, 0x6c,
        0x6c, 0x6f, 0x52, 0x65, 0x70, 0x6c, 0x79, 0x42, 0x0f, 0x5a, 0x0d, 0x2e, 0x2e, 0x2f, 0x67, 0x72,
        0x70, 0x63, 0x3b, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x62, 0x06, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x33,
}

var (
        file_hello_proto_rawDescOnce sync.Once
        file_hello_proto_rawDescData = file_hello_proto_rawDesc
)

func file_hello_proto_rawDescGZIP() []byte <span class="cov0" title="0">{
        file_hello_proto_rawDescOnce.Do(func() </span><span class="cov0" title="0">{
                file_hello_proto_rawDescData = protoimpl.X.CompressGZIP(file_hello_proto_rawDescData)
        }</span>)
        <span class="cov0" title="0">return file_hello_proto_rawDescData</span>
}

var file_hello_proto_msgTypes = make([]protoimpl.MessageInfo, 2)
var file_hello_proto_goTypes = []any{
        (*HelloRequest)(nil), // 0: hello.HelloRequest
        (*HelloReply)(nil),   // 1: hello.HelloReply
}
var file_hello_proto_depIdxs = []int32{
        0, // 0: hello.Greeter.SayHello:input_type -&gt; hello.HelloRequest
        1, // 1: hello.Greeter.SayHello:output_type -&gt; hello.HelloReply
        1, // [1:2] is the sub-list for method output_type
        0, // [0:1] is the sub-list for method input_type
        0, // [0:0] is the sub-list for extension type_name
        0, // [0:0] is the sub-list for extension extendee
        0, // [0:0] is the sub-list for field type_name
}

func init() <span class="cov0" title="0">{ file_hello_proto_init() }</span>
func file_hello_proto_init() <span class="cov0" title="0">{
        if File_hello_proto != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">type x struct{}
        out := protoimpl.TypeBuilder{
                File: protoimpl.DescBuilder{
                        GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
                        RawDescriptor: file_hello_proto_rawDesc,
                        NumEnums:      0,
                        NumMessages:   2,
                        NumExtensions: 0,
                        NumServices:   1,
                },
                GoTypes:           file_hello_proto_goTypes,
                DependencyIndexes: file_hello_proto_depIdxs,
                MessageInfos:      file_hello_proto_msgTypes,
        }.Build()
        File_hello_proto = out.File
        file_hello_proto_rawDesc = nil
        file_hello_proto_goTypes = nil
        file_hello_proto_depIdxs = nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.28.3
// source: hello.proto

package hello

import (
        context "context"
        grpc "google.golang.org/grpc"
        codes "google.golang.org/grpc/codes"
        status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
        Greeter_SayHello_FullMethodName = "/hello.Greeter/SayHello"
)

// GreeterClient is the client API for Greeter service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// The Greeter service
type GreeterClient interface {
        SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error)
}

type greeterClient struct {
        cc grpc.ClientConnInterface
}

func NewGreeterClient(cc grpc.ClientConnInterface) GreeterClient <span class="cov0" title="0">{
        return &amp;greeterClient{cc}
}</span>

func (c *greeterClient) SayHello(ctx context.Context, in *HelloRequest, opts ...grpc.CallOption) (*HelloReply, error) <span class="cov0" title="0">{
        cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
        out := new(HelloReply)
        err := c.cc.Invoke(ctx, Greeter_SayHello_FullMethodName, in, out, cOpts...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return out, nil</span>
}

// GreeterServer is the server API for Greeter service.
// All implementations must embed UnimplementedGreeterServer
// for forward compatibility.
//
// The Greeter service
type GreeterServer interface {
        SayHello(context.Context, *HelloRequest) (*HelloReply, error)
        mustEmbedUnimplementedGreeterServer()
}

// UnimplementedGreeterServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedGreeterServer struct{}

func (UnimplementedGreeterServer) SayHello(context.Context, *HelloRequest) (*HelloReply, error) <span class="cov0" title="0">{
        return nil, status.Errorf(codes.Unimplemented, "method SayHello not implemented")
}</span>
func (UnimplementedGreeterServer) mustEmbedUnimplementedGreeterServer() {<span class="cov0" title="0">}</span>
func (UnimplementedGreeterServer) testEmbeddedByValue()                 {<span class="cov0" title="0">}</span>

// UnsafeGreeterServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GreeterServer will
// result in compilation errors.
type UnsafeGreeterServer interface {
        mustEmbedUnimplementedGreeterServer()
}

func RegisterGreeterServer(s grpc.ServiceRegistrar, srv GreeterServer) <span class="cov0" title="0">{
        // If the following call pancis, it indicates UnimplementedGreeterServer was
        // embedded by pointer and is nil.  This will cause panics if an
        // unimplemented method is ever invoked, so we test this at initialization
        // time to prevent it from happening at runtime later due to I/O.
        if t, ok := srv.(interface{ testEmbeddedByValue() }); ok </span><span class="cov0" title="0">{
                t.testEmbeddedByValue()
        }</span>
        <span class="cov0" title="0">s.RegisterService(&amp;Greeter_ServiceDesc, srv)</span>
}

func _Greeter_SayHello_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) <span class="cov0" title="0">{
        in := new(HelloRequest)
        if err := dec(in); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if interceptor == nil </span><span class="cov0" title="0">{
                return srv.(GreeterServer).SayHello(ctx, in)
        }</span>
        <span class="cov0" title="0">info := &amp;grpc.UnaryServerInfo{
                Server:     srv,
                FullMethod: Greeter_SayHello_FullMethodName,
        }
        handler := func(ctx context.Context, req interface{}) (interface{}, error) </span><span class="cov0" title="0">{
                return srv.(GreeterServer).SayHello(ctx, req.(*HelloRequest))
        }</span>
        <span class="cov0" title="0">return interceptor(ctx, in, info, handler)</span>
}

// Greeter_ServiceDesc is the grpc.ServiceDesc for Greeter service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Greeter_ServiceDesc = grpc.ServiceDesc{
        ServiceName: "hello.Greeter",
        HandlerType: (*GreeterServer)(nil),
        Methods: []grpc.MethodDesc{
                {
                        MethodName: "SayHello",
                        Handler:    _Greeter_SayHello_Handler,
                },
        },
        Streams:  []grpc.StreamDesc{},
        Metadata: "hello.proto",
}
</pre>
		
		<pre class="file" id="file2" style="display: none">// Code generated by MockGen. DO NOT EDIT.
// Source: hello/generated/hello_grpc.pb.go

// Package mock is a generated GoMock package.
package mock

import (
        context "context"
        reflect "reflect"

        gomock "github.com/golang/mock/gomock"
        generated "github.com/hello/hello/generated"
        grpc "google.golang.org/grpc"
)

// MockGreeterClient is a mock of GreeterClient interface.
type MockGreeterClient struct {
        ctrl     *gomock.Controller
        recorder *MockGreeterClientMockRecorder
}

// MockGreeterClientMockRecorder is the mock recorder for MockGreeterClient.
type MockGreeterClientMockRecorder struct {
        mock *MockGreeterClient
}

// NewMockGreeterClient creates a new mock instance.
func NewMockGreeterClient(ctrl *gomock.Controller) *MockGreeterClient <span class="cov0" title="0">{
        mock := &amp;MockGreeterClient{ctrl: ctrl}
        mock.recorder = &amp;MockGreeterClientMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGreeterClient) EXPECT() *MockGreeterClientMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SayHello mocks base method.
func (m *MockGreeterClient) SayHello(ctx context.Context, in *generated.HelloRequest, opts ...grpc.CallOption) (*generated.HelloReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        varargs := []interface{}{ctx, in}
        for _, a := range opts </span><span class="cov0" title="0">{
                varargs = append(varargs, a)
        }</span>
        <span class="cov0" title="0">ret := m.ctrl.Call(m, "SayHello", varargs...)
        ret0, _ := ret[0].(*generated.HelloReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1</span>
}

// SayHello indicates an expected call of SayHello.
func (mr *MockGreeterClientMockRecorder) SayHello(ctx, in interface{}, opts ...interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        varargs := append([]interface{}{ctx, in}, opts...)
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SayHello", reflect.TypeOf((*MockGreeterClient)(nil).SayHello), varargs...)
}</span>

// MockGreeterServer is a mock of GreeterServer interface.
type MockGreeterServer struct {
        ctrl     *gomock.Controller
        recorder *MockGreeterServerMockRecorder
}

// MockGreeterServerMockRecorder is the mock recorder for MockGreeterServer.
type MockGreeterServerMockRecorder struct {
        mock *MockGreeterServer
}

// NewMockGreeterServer creates a new mock instance.
func NewMockGreeterServer(ctrl *gomock.Controller) *MockGreeterServer <span class="cov0" title="0">{
        mock := &amp;MockGreeterServer{ctrl: ctrl}
        mock.recorder = &amp;MockGreeterServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockGreeterServer) EXPECT() *MockGreeterServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// SayHello mocks base method.
func (m *MockGreeterServer) SayHello(arg0 context.Context, arg1 *generated.HelloRequest) (*generated.HelloReply, error) <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        ret := m.ctrl.Call(m, "SayHello", arg0, arg1)
        ret0, _ := ret[0].(*generated.HelloReply)
        ret1, _ := ret[1].(error)
        return ret0, ret1
}</span>

// SayHello indicates an expected call of SayHello.
func (mr *MockGreeterServerMockRecorder) SayHello(arg0, arg1 interface{}) *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "SayHello", reflect.TypeOf((*MockGreeterServer)(nil).SayHello), arg0, arg1)
}</span>

// mustEmbedUnimplementedGreeterServer mocks base method.
func (m *MockGreeterServer) mustEmbedUnimplementedGreeterServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedGreeterServer")
}</span>

// mustEmbedUnimplementedGreeterServer indicates an expected call of mustEmbedUnimplementedGreeterServer.
func (mr *MockGreeterServerMockRecorder) mustEmbedUnimplementedGreeterServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedGreeterServer", reflect.TypeOf((*MockGreeterServer)(nil).mustEmbedUnimplementedGreeterServer))
}</span>

// MockUnsafeGreeterServer is a mock of UnsafeGreeterServer interface.
type MockUnsafeGreeterServer struct {
        ctrl     *gomock.Controller
        recorder *MockUnsafeGreeterServerMockRecorder
}

// MockUnsafeGreeterServerMockRecorder is the mock recorder for MockUnsafeGreeterServer.
type MockUnsafeGreeterServerMockRecorder struct {
        mock *MockUnsafeGreeterServer
}

// NewMockUnsafeGreeterServer creates a new mock instance.
func NewMockUnsafeGreeterServer(ctrl *gomock.Controller) *MockUnsafeGreeterServer <span class="cov0" title="0">{
        mock := &amp;MockUnsafeGreeterServer{ctrl: ctrl}
        mock.recorder = &amp;MockUnsafeGreeterServerMockRecorder{mock}
        return mock
}</span>

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnsafeGreeterServer) EXPECT() *MockUnsafeGreeterServerMockRecorder <span class="cov0" title="0">{
        return m.recorder
}</span>

// mustEmbedUnimplementedGreeterServer mocks base method.
func (m *MockUnsafeGreeterServer) mustEmbedUnimplementedGreeterServer() <span class="cov0" title="0">{
        m.ctrl.T.Helper()
        m.ctrl.Call(m, "mustEmbedUnimplementedGreeterServer")
}</span>

// mustEmbedUnimplementedGreeterServer indicates an expected call of mustEmbedUnimplementedGreeterServer.
func (mr *MockUnsafeGreeterServerMockRecorder) mustEmbedUnimplementedGreeterServer() *gomock.Call <span class="cov0" title="0">{
        mr.mock.ctrl.T.Helper()
        return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "mustEmbedUnimplementedGreeterServer", reflect.TypeOf((*MockUnsafeGreeterServer)(nil).mustEmbedUnimplementedGreeterServer))
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
